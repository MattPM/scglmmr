---
title: "nested group repeated measures pseudobulk differential expression testing"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pseudobulk differential expression with nested group repeated measures single cell experiment designs using scglmmr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  eval = FALSE
)
```

### 1. pseudobulk mixed effects models  
These functions implement convenience wrappers around both `limma` for fitting traditional linear models (for e.g. baseline differenced between groups) and the `dream` method from the `variancePartition` package. This is the only pseudobulk differential expression method that can accomodate both fixed and random effects (which are statistically necessary to account for non-independence of multiple measurements from the same donor) via use of `lme4` for mixed effects modeling while accounting for measurement uncertainty via pooling unqeual library sizes by incorporating `voom` observational weights. This method performed well in related simulation studies by [Crowell et. al. 2020](https://www.nature.com/articles/s41467-020-19894-4). scglmmr performs statistical contrasts between groups comparing the least squares means after accounting for model covariates is empowered by the [emmeans](https://cran.r-project.org/web/packages/emmeans/index.html) package.  


```{r, eval = FALSE}
library(scglmmr)
```

Below is a 2 group repeated measures experiment. A random intercept model is required to account for autocorrelation in each donors post perturbation response with their baseline level of expression. This data can be accomodated by scglmmr. More simple experiment designs are also supported, for example data with 2 groups but not repeated pre/post treatment measurements, see the `RunVoomLimma()` function.

| sample        | sampleid      | time    |   group        | sex            
| :------------- | :----------: | -----------: | :------------- | :----------: | 
|  101_t0     | 101           | d0           |  low            | F            | 
|  101_t1     | 101           | d1           |  high           | F            | 
|  102_t0     | 102           | d0           |  low            | M           | 
|  102_t1     | 102           | d1           |  high           | M             | 
|  ... (x n donors)    | ... (x n donors)           | ... (x n donors)           |  ... (x n donors)           | ... (x n donors)             | 


### 1. "Pseudobulk" mixed effects model

Fit a weighted mixed effects model to test group and time effects using lme4 model formula syntax and using dream observational weights using `dream` from the `variancePartition` package. 

```{r, eval = FALSE}
#devtools::install_github(repo = "https://github.com/MattPM/scglmmr")
library(scglmmr)
datapath = "mypath/"

# load seurat or sce object etc. 
s = readRDS("path/seuratobject.rds")

# define counts and metadata and subset to cells above rm seurat object from workspace 
meta = s@meta.data
umi = s@assays$RNA@counts
rm(s); gc()

# QC contingency of cells by subject for each celltype 
tab = scglmmr::SubjectCelltypeTable(metadata = meta, celltype_column = "celltype", sample_column = "sample")
tab$celltypes_remove; tab$`low representation celltypes`; tab$table

# remove cells prior to pseudobulk analysis 
meta = meta[!meta$celltype_label_3 %in% tab$celltypes_remove, ]

# subset data 
umi = umi[ ,rownames(meta)]

# pseudobulk workflow 
pb = scglmmr::PseudobulkList(rawcounts = umi,
                             metadata = meta, 
                             sample_col = "sample",
                             celltype_col = "celltype",
                             avg_or_sum = "sum")
# designmat = scglmmr::BulkDesignMatrix(metadata = meta, 
#                                       sample_column = "sample",
#                                       variable_column = "cohort_timepoint", 
#                                       pseudobulklist = pb)


dge = scglmmr::NormalizePseudobulk(pseudobulklist = pb, 
                                   design_matrix = designmat,
                                   minimum.gene.count = 5)

md = AggregateCellMetadata(cell.metadata = meta, 
                           variables c('scaledage', 'sex', 'time.group', 'subjectid' ),
                           sample.column = 'sample')



# example of using a custom contrast: 
# re-level time.group into ordered combined factor
samplemd$time.group = factor(
  samplemd$time.group,
  levels = c('d0_group1', 'd1_group1', 'd0_group2', 'd1_group2')
  )

# specify random intercept model 
f1 <- ~ 0 + time.group + gender + scaledage + (1|subjectid)

# specify contrast matrix to test the fold change difference
# based on levels of time.group this should be cmat = c(-1, 1, 1, -1, 0, 0)
# the age and gender other main effects in the model should all be 0 in L 
L2 = makeContrastsDream(
  formula = f1, 
  data = samplemd,
  contrasts = c(
    baseline = "time.groupd0_group1- time.groupd0_group2", 
    delta = "(time.groupd1_group1 - time.groupd0_group1) - (time.groupd1_group2 - time.groupd0_group2)",
    treatment = "( time.groupd1_group1 + time.groupd1_group2 ) / 2 - ( time.groupd0_group1 + time.groupd0_group2 ) / 2 "
  )
)


  
# fit mixed model for the multi timepoint contrasts 
fit = scglmmr::dreamMixedModel(dge_lists = dge, 
                               apriori_contrasts = TRUE, 
                               sample_column = 'sample',
                               cell_metadata = meta, 
                               contrast_matrix = c_mat, 
                               design_matrix = designmat, 
                               lme4_formula =  '~ 0 + age + gender + cohort_timepoint + (1|sampleid)', 
                               fixed_effects = c('age', 'gender', 'cohort_timepoint'), 
                               plotsavepath = figpath, 
                               ncores = 4)

# fit simple linear model for the baseline group level contrast 
bl = scglmmr::RunVoomLimma(dgelists = dge, 
                           design_matrix = designmat, 
                           do_contrast_fit = T,
                           my_contrast_matrix = c_mat[ ,3])

# save 
saveRDS(bl, file = paste0(datapath, "blfit_object.rds"))
saveRDS(fit, file = paste0(datapath, "fit_object.rds"))
```

### Downstream analysis on pseudobulk results
Here we provide examples of downstream analysis on results of the model fit above focusing on the first contrast (the first coefficient in the results), corresponding to:  
foldchange_difference = (group_timepoint1_1 - group_timepoint1_0) - (group_timepoint0_1 - group_timepoint0_0)  
```{r, eval=FALSE}
# hlmk = readRDS(file = here("signature_curation/hallmark.rds"))
figpath = "your/path"
test = scglmmr::GetRankResults(limma.fit.object.list = bl, coefficient.number = 1, "test")
res = scglmmr::GetContrastResults(limma.fit.object.list = bl, coefficient.number = 1, contrast.name = "test")

# get the mixed effects model results for the difference in fold changes 
fit_res = scglmmr::GetContrastResultsRaw(limma.fit.object.list = fit, 
                                         coefficient.number = 1,
                                         contrast.name = "foldchangedifference")
fit_rank = scglmmr::GetRankResultsRaw(contrast.result.raw.list = fit_res)


# Gene Set Enrichment Analysis 
gsea1 = scglmmr::RunFgseaOnRankList(rank.list.celltype = test, pathways = hlmk)
d = scglmmr::RbindGseaResultList(gsea_result_list = gsea1,NES_filter = -Inf,padj_filter = 0.2)
scglmmr::GSEABubblePlot(d, save_path = figpath, save_name = "plot.pdf")
# also see scglmmr::GSEABarPlot()

# full set of leading edge genes vs celltypes 
lefull = scglmmr::GetLeadingEdgeFull(gsea.list = gsea1, padj.filter = 0.1,NES.filter = -Inf)

# combine GSEA results with model coefficient for each gene in leading edge 
cr = scglmmr::CombineResults(gsealist = gsea1, contrastlist = res, gseafdr = 0.1, genefdr = 1)


# make tidy average data for visualization of weighted pb results 
av = scglmmr::PseudobulkList(rawcounts = umi, 
                             metadata = meta, 
                             sample_col = "sample", 
                             celltype_col = "celltype",
                             avg_or_sum = 'average')
le_expr = scglmmr::LeadEdgeTidySampleExprs(av.exprs.list = av,
                                           gsea.list = hlmk_ctm0, 
                                           padj.filter = 0.1,
                                           NES.filter = -Inf)


# example plot of sample level average leading edge genes annotated 
scglmmr::LeadEdgeSampleHeatmap(tidy.exprs.list = le_expr,
                               modulename = "MODULENAME",
                               elltype_plot = "TCELL",
                               metadata = meta, 
                               metadata_annotate = c('group', 'timepoint', 'age', 'gender'),
                               sample_column = 'sample',
                               returnmat = F, 
                               savepath = figpath, 
                               savename = "filename")

# see also: 
# scglmmr::TopGenesTidySampleExprs() - same as aobve for 'top' de genes estimated by model coeffcient / p value. 
# scglmmr::GetTidySummary() - for custom plotting


# repeat this for all enriched pathways 
heatpath = here("sime/path"); dir.create(heatpath)
for (i in 1:length(le_expr)) {
  cdat = le_expr[[i]]
  ctype = names(le_expr[i])
  umod = unique(cdat$module)
  for (u in 1:length(umod)) {
    scglmmr::LeadEdgeSampleHeatmap(tidy.exprs.list = le_expr, 
                          modulename = umod[u], 
                          celltype_plot = ctype,
                          metadata = meta, metadata_annotate = c('group', 'timepoint', 'age', 'gender'),
                          sample_column = 'sample',
                          returnmat = F, 
                          savepath = heatpath,
                          savename = paste0(ctype, " ",umod[u],'.pdf'))
  }
}

# plot only the leading edge genes from enrichment in a heatmap of log Fold Change estimated for a model contrast 
le = scglmmr::GetLeadingEdgeFull(gsea.list = gsea1, padj.filter = 0.1, NES.filter = -Inf)
genesub = do.call(rbind, le) %$% gene %>% unique 
mtx2 = scglmmr::GetGeneMatrix(result.list = res, 
                    stat_for_matrix = "logFC",
                    gene_subset = genesub, 
                    pvalfilter = -Inf, 
                    logfcfilter = 0.1)

pheatmap::pheatmap(mtx2,
                   breaks =seq(from = 0, to = 2,length.out = 99),
                   filename = paste0(figpath,"LEgenes_heatmap.pdf"))



### Hypergeometric erichment 
load(termdf) # this term2gene dataframe is included in the package see clusterProfiler
hyp = scglmmr::RunHypergeometricTest(result_list = fit_res,
                                     TERM2GENE_dataframe = termdf,
                                     pval_threshold = 0.1,
                                     logFC_threshold = 0,
                                     usefdr_threshold = FALSE)
# plot results 
scglmmr::PlotHypergeometric(hyperg_result = hyp, 
                            p.adjust.filter = 0.1,
                            genenumber_filter = 2,
                            savepath = figpath,
                            savename = "name", 
                            title = "title")

# calculate average module z score across samples (z score across samples of gene z scores)
# baseline_samples = c('') # user defined vector 
lapply(av, function(x), x[ ,baseline_samples])
mz = scglmmr::AverageSampleModuleZscore(average.metacell.list = av,
                                        module.list = hlmk,use.module.subset = F)


```
