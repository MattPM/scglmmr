---
title: "Pseudobulk differential expression with nested group repeated measures single cell experiment designs using scglmmr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pseudobulk differential expression with nested group repeated measures single cell experiment designs using scglmmr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

### 1. pseudobulk mixed effects models  
These functions implement convenience wrappers around both `limma` for fitting traditional linear models (for e.g. baseline differenced between groups) and the `dream` method from the `variancePartition` package. This is the only pseudobulk differential expression method that can accomodate both fixed and random effects (which are statistically necessary to account for non-independence of multiple measurements from the same donor) via use of `lme4` for mixed effects modeling while accounting for measurement uncertainty via pooling unqeual library sizes by incorporating `voom` observational weights. This method performed well in related simulation studies by [Crowell et. al. 2020](https://www.nature.com/articles/s41467-020-19894-4). scglmmr performs statistical contrasts between groups comparing the least squares means after accounting for model covariates is empowered by the [emmeans](https://cran.r-project.org/web/packages/emmeans/index.html) package.  


```{r, eval = FALSE}
library(scglmmr)
```

Below is a 2 group repeated measures experiment. A random intercept model is required to account for autocorrelation in each donors post perturbation response with their baseline level of expression. This data can be accomodated by scglmmr. More simple experiment designs are also supported, for example data with 2 groups but not repeated pre/post treatment measurements, see the `RunVoomLimma()` function.

| sample        | sampleid      | timepoint    |   Group        | gender            
| :------------- | :----------: | -----------: | :------------- | :----------: | 
|  101_t0     | 101           | d0           |  low            | F            | 
|  101_t1     | 101           | d1           |  high           | F            | 
|  102_t0     | 102           | d0           |  low            | M           | 
|  102_t1     | 102           | d1           |  high           | M             | 
|  ... (x n donors)    | ... (x n donors)           | ... (x n donors)           |  ... (x n donors)           | ... (x n donors)             | 


### 1. "Pseudobulk" mixed effects model

In the case of pseudobulk libraries derived from single cell RNAseq data, interpolated model weights should correlate with library sizes within each cell type. Indeed we confirmed that the log count per million and square root standard deviation of genes had the expected monotonically decreasing trend within each cell type and that the resulting interpolated model weights across genes in a given sample were highly correlated with both the number of cells used to create the library and the sample’s total mRNA library size. Later, a more recent report introduced the muscat R package and simulation studies for testing within cluster differential expression. 
10.1101/713412. This paper included simulation and validation studies of established bulk RNAseq methods for within cluster differential expression analysis. In that report, a pseudobulk method that performed particularly well was using limma with voom observational weights, and mixed effects (i.e. the ability to specify a random effect for donor baseline expression) with lme4 model formula implemented through the “dream” method available through the vairance partition package. We implemented a weighted mixed effects model using this limma + voom + lme4 method within each cell type using a random intercept for each donor with contrast coding to test for group level fold change differences.  

```{r, eval = FALSE}
#devtools::install_github(repo = "https://github.com/MattPM/scglmmr")
library(scglmmr)
datapath = "mypath/"

# load seurat or sce object etc. 
s = readRDS("path/seuratobject.rds")

# define counts and metadata and subset to cells above rm seurat object from workspace 
meta = s@meta.data
umi = s@assays$RNA@counts
rm(s); gc()

# QC contingency of cells by subject for each celltype 
tab = scglmmr::SubjectCelltypeTable(metadata = meta, celltype_column = "lineage", sample_column = "sample")
tab$celltypes_remove; tab$`low representation celltypes`; tab$table

# remove cells prior to pseudobulk analysis 
meta = meta[!meta$celltype_label_3 %in% tab$celltypes_remove, ]

# subset data 
umi = umi[ ,rownames(meta)]

# pseudobulk workflow 
pb = scglmmr::PseudobulkList(rawcounts = umi, metadata = meta, sample_col = "sample",
                             celltype_col = "lineage", avg_or_sum = "sum")
designmat = scglmmr::BulkDesignMatrix(metadata = meta, sample_column = "sample",
                                      variable_column = "cohort_timepoint", pseudobulklist = pb)
dge = scglmmr::NormalizePseudobulk(pseudobulklist = pb, design_matrix = designmat, minimum.gene.count = 5)

# custom a priori contrasts over a combined factor of the group and timepoint variables 
c_mat = makeContrasts(
  foldchange_difference = (group_timepoint1_1 - group_timepoint1_0) - (group_timepoint0_1 - group_timepoint0_0),
  time1_foldchange = (group_timepoint1_1 + group_timepoint0_1) / 2  - (group_timepoint1_0 + group_timepoint0_0) / 2,
  baseline_groups = (group_timepoint1_0 - group_timepoint0_0),
  levels = colnames(designmat)
)
  
# fit mixed model for the multi timepoint contrasts 
fit = scglmmr::dreamMixedModel(dge_lists = dge, 
                               apriori_contrasts = TRUE, 
                               sample_column = 'sample',
                               cell_metadata = meta, 
                               contrast_matrix = c_mat, 
                               design_matrix = designmat, 
                               lme4_formula =  '~ 0 + age + gender + cohort_timepoint + (1|sampleid)', 
                               fixed_effects = c('age', 'gender', 'cohort_timepoint'), 
                               plotsavepath = figpath, 
                               ncores = 4)

# fit simple linear model for the baseline group level contrast 
bl = scglmmr::RunVoomLimma(dgelists = dge, 
                           design_matrix = designmat, 
                           do_contrast_fit = T,
                           my_contrast_matrix = c_mat[ ,3])

# save 
saveRDS(bl, file = paste0(datapath, "blfit_object.rds"))
saveRDS(fit, file = paste0(datapath, "fit_object.rds"))
```

### Downstream analysis on pseudobulk results
Here we provide examples of downstream analysis on results of the model fit above focusing on the first contrast (the first coefficient in the results), corresponding to:  
foldchange_difference = (group_timepoint1_1 - group_timepoint1_0) - (group_timepoint0_1 - group_timepoint0_0)  
```{r, eval=FALSE}
# hlmk = readRDS(file = here("signature_curation/hallmark.rds"))
figpath = "your/path"
test = scglmmr::GetRankResults(limma.fit.object.list = bl, coefficient.number = 1, "test")
res = scglmmr::GetContrastResults(limma.fit.object.list = bl, coefficient.number = 1, contrast.name = "test")

# get the mixed effects model results for the difference in fold changes 
fit_res = scglmmr::GetContrastResultsRaw(limma.fit.object.list = fit, 
                                         coefficient.number = 1,
                                         contrast.name = "foldchangedifference")
fit_rank = scglmmr::GetRankResultsRaw(contrast.result.raw.list = fit_res)


# Gene Set Enrichment Analysis 
gsea1 = scglmmr::RunFgseaOnRankList(rank.list.celltype = test, pathways = hlmk)
d = scglmmr::RbindGseaResultList(gsea_result_list = gsea1,NES_filter = -Inf,padj_filter = 0.2)
scglmmr::GSEABubblePlot(d, save_path = figpath, save_name = "plot.pdf")
# also see scglmmr::GSEABarPlot()

# full set of leading edge genes vs celltypes 
lefull = scglmmr::GetLeadingEdgeFull(gsea.list = gsea1, padj.filter = 0.1,NES.filter = -Inf)

# combine GSEA results with model coefficient for each gene in leading edge 
cr = scglmmr::CombineResults(gsealist = gsea1, contrastlist = res, gseafdr = 0.1, genefdr = 1)


# make tidy average data for visualization of weighted pb results 
av = scglmmr::PseudobulkList(rawcounts = umi, 
                             metadata = meta, 
                             sample_col = "sample", 
                             celltype_col = "celltype",
                             avg_or_sum = 'average')
le_expr = scglmmr::LeadEdgeTidySampleExprs(av.exprs.list = av,
                                           gsea.list = hlmk_ctm0, 
                                           padj.filter = 0.1,
                                           NES.filter = -Inf)


# example plot of sample level average leading edge genes annotated 
scglmmr::LeadEdgeSampleHeatmap(tidy.exprs.list = le_expr,
                               modulename = "MODULENAME",
                               elltype_plot = "TCELL",
                               metadata = meta, 
                               metadata_annotate = c('group', 'timepoint', 'age', 'gender'),
                               sample_column = 'sample',
                               returnmat = F, 
                               savepath = figpath, 
                               savename = "filename")

# see also: 
# scglmmr::TopGenesTidySampleExprs() - same as aobve for 'top' de genes estimated by model coeffcient / p value. 
# scglmmr::GetTidySummary() - for custom plotting


# repeat this for all enriched pathways 
heatpath = here("sime/path"); dir.create(heatpath)
for (i in 1:length(le_expr)) {
  cdat = le_expr[[i]]
  ctype = names(le_expr[i])
  umod = unique(cdat$module)
  for (u in 1:length(umod)) {
    scglmmr::LeadEdgeSampleHeatmap(tidy.exprs.list = le_expr, 
                          modulename = umod[u], 
                          celltype_plot = ctype,
                          metadata = meta, metadata_annotate = c('group', 'timepoint', 'age', 'gender'),
                          sample_column = 'sample',
                          returnmat = F, 
                          savepath = heatpath,
                          savename = paste0(ctype, " ",umod[u],'.pdf'))
  }
}

# plot only the leading edge genes from enrichment in a heatmap of log Fold Change estimated for a model contrast 
le = scglmmr::GetLeadingEdgeFull(gsea.list = gsea1, padj.filter = 0.1, NES.filter = -Inf)
genesub = do.call(rbind, le) %$% gene %>% unique 
mtx2 = scglmmr::GetGeneMatrix(result.list = res, 
                    stat_for_matrix = "logFC",
                    gene_subset = genesub, 
                    pvalfilter = -Inf, 
                    logfcfilter = 0.1)

pheatmap::pheatmap(mtx2,
                   breaks =seq(from = 0, to = 2,length.out = 99),
                   filename = paste0(figpath,"LEgenes_heatmap.pdf"))



### Hypergeometric erichment 
load(termdf) # this term2gene dataframe is included in the package see clusterProfiler
hyp = scglmmr::RunHypergeometricTest(result_list = fit_res,
                                     TERM2GENE_dataframe = termdf,
                                     pval_threshold = 0.1,
                                     logFC_threshold = 0,
                                     usefdr_threshold = FALSE)
# plot results 
scglmmr::PlotHypergeometric(hyperg_result = hyp, 
                            p.adjust.filter = 0.1,
                            genenumber_filter = 2,
                            savepath = figpath,
                            savename = "name", 
                            title = "title")

# calculate average module z score across samples (z score across samples of gene z scores)
# baseline_samples = c('') # user defined vector 
lapply(av, function(x), x[ ,baseline_samples])
mz = scglmmr::AverageSampleModuleZscore(average.metacell.list = av,
                                        module.list = hlmk,use.module.subset = F)


```
